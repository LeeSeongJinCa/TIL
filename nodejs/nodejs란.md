# node.js 란?
---
__Node.js__ 는 __서버사이드 자바스크립트__ 이며 구글의 자바스크립트 엔진 __V8__ 을 기반으로 구성된 일종의 소프트웨어 시스템이다.

이벤트 기반으로 개발이 가능하며 __Non blocking I/O__ 을 지원하기 때문에 __비동기 프로그래밍__ 이 가능하다. 이로 인하여 I/O가 심한 대규모 서비스를 하기에 적합하다.

노드는 서버에서 클라이언트의 요청, __즉 연결을 처리하는 방법을 새로운 컨셉으로 변경__ 하여 이 문제를 해결합니다.

기존에는 각 연결에 대해 새로운 쓰레드를 생성하고 처리했던 반면, 노드는 __각 연결이 하나의 이벤트로서 노드 엔진에서 처리됩니다.__

### 이벤트 기반 비동기 방식

---
노드가 뛰어난 성능을 발휘할 수 있었던 이유는 __비동기 이벤트 기반 아키텍쳐__ 와 __구글의 V8 자바스크립트 엔진__ 을 사용했기 때문입니다.

#### 비동기 이벤트 기반 vs 쓰레드 기반
---
지금까지 대부분의 어플리케이션에서 Blocking I/O를 사용하였습니다. 이 때문에 멀티 쓰레드를 사용할 수 밖에 없었고, 이는 어쩔 수 없는 선택이지만 네트워크에서 동시에 대규모 요청을 처리하는 데 부적절합니다.


<p style="font-size: 20px;">Blocking I/O</p>

---
Blocking I/O에 간략하게 설명하자면 __"하나의 프로세스가 어떤 자원을 사용하고 싶을 때 만약 다른 프로세스가 자원을 사용하고 있다면 그 프로세스가 끝날 때 까지 기다려야 하는 것"__ 입니다.
<img src="https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dNOma_1488263111120/1488263625769_image.png" />

어플리케이션을 운영체제가 읽기 위해서 스시템 콜이라는 요청을 보냅니다. 운영체제는 시스템 콜을 받고 파일 읽기를 위한 동작을 수행합니다. 그리고 파일을 다 읽을 때까지 기다려야 합니다. 이 동안 어플리케이션은 아무 동작도 하지 못 합니다.

#### 멀티 쓰레드
---
일반적으로 하나의 쓰레드가 하나의 프로세스를 담당합니다. 만약 웹 서버와 같이 다수의 요청이 들어오게 된다면 멀티 쓰레드라는 개념을 사용할 수 밖에 없습니다.

멀티 쓰레드는 말 그대로 여러 개가 동시에 실행되어 요청을 처리하는 개념입니다.

#### 쓰레드로 인해 발생하는 문제점
--- 
1. __복수의 요청으로 인해 발생하는 공유 문제를 해결할 수 없다.__
2. __I/O 요청을 하고 응답이 올 때까지 아무것도 하지않고 시간을 낭비한다.__
3. __문맥 전환(Content switch)__ 비용이 발생한다.
    - 즉, 쓰레드를 분할하고 사용하기 위해 스케줄링을 하는 것 자체가 CPU를 이용한 연산이 필요합니다.
    - 또, 쓰레드 간의 전환, 복귀, 상태 저장 등 모두 CPU의 연산이 필요하고 이 경우 비용이 든다는 문제점이 있습니다.

#### 싱글 쓰레드와 이벤트 기반 비동기 I/O 처리
---
노드는 이러한 문제를 __싱글 쓰레드__ 와 __이벤트 기반 비동기 I/O 처리로 해결__ 하고 그 성능을 끌어올릴 수 있도록 하는 비동기 프로그래밍 모델을 제공해줍니다.

싱글 쓰레드를 가진 노드는 I/O 작업이 시작되면 I/O 작업 처리에 대한 응답을 기다리지 않고 바로 다음 작업을 실행합니다. 대신 I/O 작업이 종료되면 이벤트를 발생시키고, 이 이벤트는 해당 프로세스의 큐에 등록됩니다. 노드는 이 프로세스의 이벤트를 감지하여, 수행해야할 이벤트를 발생시킵니다.

#### 이벤트 루프
---
이벤트 루프(Event Loop)라는 것은 작업이 요청하면서 작업이 완료되었을 때 수행할 작업을 콜백 함수로 전달하여 __동작이 완료되었을 때 콜백 함수를 실행하는 동작 방식__ 을 말합니다.

만약 클라이언트가 웹 서버에 HTTP 요청을 보내면 이벤트 루프는 이를 감지하여 이벤트 큐에 등록하고 바로 다음 이벤트를 기다립니다.

다시 말해 이벤트 루프는 __어떤 요청이 발생하면 그 작업에 대한 쓰레드만 실행__ 합니다. 이 후 작업을 할당받았던 쓰레드가 모든 작업을 마치면 콜백 함수를 실행하도록 이벤트 루프로 응답하게 되며 이벤트 루프는 이를 클라이언트에게 응답해줍니다.




### Node.js 특징
---
__비동기 처리 방식__ 이 효율적인 것은 알겠지만 이 것만으론 노드에게 매력을 느끼기 부족합니다. 그래서 Node.js의 또 다른 특징을 알아보도록 하겠습니다.
#### 자바스크립트 기반
---
자바스크립트는 원래 프론트 개발을 위해 사용하던 언어입니다. 하지만 노드를 사용하면 __프론트와 백이 공통된 언어를 사용__ 합니다. 이는 단순히 개발 언어의 통일 만을 의미하지 않습니다. 하나의 언어로 개발하게 되면 프론트와 백이 좀 더 긴밀한 구조로 설계될 수 있고, 같은 프로그래머가 양쪽 모두를 개발할 수 있습니다. 따라서 개발 단계에서 유지보수나 인력의 시간을 줄일 수 있으며, 코드 통합이 쉬워집니다.

#### 이벤트 기반의 프로그래밍 모델
---
jQuery라는 라이브러리가 널리 퍼져있습니다. jQuery는 이벤트 기반 프로그래밍 모델을 가지고 있습니다. 이러한 jQuery로 개발한다면 더 익숙한 개발을 할 수 있습니다.

#### NPM을 통한 다양한 확장 모듈들
---
__NPM__ 이라는 __설치 관리자__ 를 통해 확장 모듈을 쉽게 설치할 수 있습니다. NPM을 통한 다양한 기능을 가진 확장 모듈들은 노드의 보급에 큰 영향을 끼쳤습니다.


### Node.js 의 아키텍쳐
---
<img src="https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_kVVqd_1533200523344/056fbc6066a6b4f3379325043c03eb39c44d77e90196df7900de98044c4708cc.png" />

- C/C++과 자바스크립트로 만들어졋습니다.
- 노드는 기본적으로 구글의 V8엔진 위에서 구동합니다.
- 게다가 V8엔진은 멀티 프로세스 모델에서 실행되는 것을 목표로 만들어 졌기 때문에 서버에서 동작하도록 일종의 용도 변경이 이루어졌습니다.
- 이벤트를 받아 처리하는 기능이 있습니다. 특히 노드는 서버 쪽에서 동작하는 프로그램을 만드는 것이 주 목적이기 때문에 '소켓'이나 'HTTP 프로토콜' 을 사용해 데이터를 송수신하는 기능을 포함하고 있습니다.

위의 사진은 초창기 노드의 아키텍쳐이며 현재는 변경된 점이 있다고 합니다.
<img src="https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_kVVqd_1533200523344/a0049d4b85d55ac50c8825c2ab88410bb55b321322f05b232af3341477d78d9b.png" />

##### 노드 표준 라이브러리(Node standard library)
실질적으로 V8엔진과 연결되어 특정한 수행을 하도록 도와주는 자바스크립트의 기본 라이브러리입니다. 자바스크립트로 만들어 졌으며 이를 통해 노드와 연결합니다.

##### 노드 바인딩(Node bindings)
C/C++로 구성된 시스템 바인딩 레이어입니다. 소켓, Http 등의 통신 기능이 제공되지만, DOM에 관한 기능은 제공되고 있지 않습니다.

##### V8 엔진
구글에서 개발한 오픈소스 JIT 가상머신 형식의 자바스크립트 엔진입니다.

##### 쓰레드 풀(thread pool)
파일 관련 작업을 수행합니다. 이벤트 기반이 모두 비동기로 처리되어 있습니다. 파일 관련 작업을 모두 비동기로 처리합니다. 

##### 이벤트 루프(event loop)
이벤트 루프는 libev로 구성되어 있습니다.

##### C-ares
동시에 복수의 DNS 요청을 비동기적으로 처리하기 위한 C언어 라이브러리입니다.

### 웹 서버를 통한 Hello! Node.js!
``` javascript
let server = require('http');
server.createServer((req, res) => {
    res.writeHead(200, { "Content-Type" : "text/plain" });
    res.end("Hello! Node.js! \n");
}).listen(3000, 'localhost');
console.log("Server is running at http://localhost:3000/");
```
파일을 불러오기 
``` javascript
let fs = require('fs');
fs.readFile('hello.txt', encoding='utf-8', (err, data) => {
    if(err) {
        throw err;
    }
    console.log(data + " Node.js!");
});
```
이벤트 루프 사용하기
``` javascript
let Eventmitter = require('events').EventEmitter;
let evt = new Eventmitter();
evt.on("helloNode", (str) => {
    console.log("Hello! " + str);
});
setTimeout(() => {
    evt.emit("helloNode", "Node.js");
}, 3000);
```